# 微服务架构下的安全认证与鉴权
## 单体应用 VS 微服务
  随着微服务架构的兴起，传统的单体应用场景下的身份认证和鉴权面临的挑战越来越大。单体应用体系下，应用是一个整体，一般针对所有的请求都会进行权限校验。请求一般会通过一个权限的拦截器进行权限的校验，在登录时将用户信息缓存到 session 中，后续访问则从缓存中获取用户信息。

![image-20201022221844421](.\img\单体应用权限拦截)

  而微服务架构下，一个应用会被拆分成若干个微应用，每个微应用都需要对访问进行鉴权，每个微应用都需要明确当前访问用户以及其权限。尤其当访问来源不只是浏览器，还包括其他**服务**的调用时，单体应用架构下的鉴权方式就不是特别合适了。在微服务架构下，要考虑外部应用接入的场景、**用户 - 服务的鉴权、服务 - 服务的鉴权**等多种鉴权场景。

![image-20201022222029348](.\img\微服务下鉴权)

David Borsos 在伦敦的微服务大会上提出了四种方案：

1. 单点登录（SSO）
这种方案意味着每个面向用户的服务都必须与认证服务交互，这会产生大量非常琐碎的网络流量和重复的工作，当动辄数十个微应用时，这种方案的弊端会更加明显。
2. 分布式 Session 方案
分布式会话方案原理主要是将关于用户认证的信息存储在共享存储中，且通常由用户会话作为 key 来实现的简单分布式哈希映射。当用户访问微服务时，用户数据可以从共享存储中获取。在某些场景下，这种方案很不错，用户登录状态是不透明的。同时也是一个高可用且可扩展的解决方案。这种方案的缺点在于共享存储需要一定保护机制，因此需要通过安全链接来访问，这时解决方案的实现就通常具有相当高的复杂性了。
3. 客户端 Token 方案
令牌在客户端生成，由身份验证服务进行签名，并且必须包含足够的信息，以便可以在所有微服务中建立用户身份。令牌会附加到每个请求上，为微服务提供用户身份验证，这种解决方案的安全性相对较好，但身份验证注销是一个大问题，缓解这种情况的方法可以使用短期令牌和频繁检查认证服务等。对于客户端令牌的编码方案，Borsos 更喜欢使用 JSON Web Tokens（JWT），它足够简单且库支持程度也比较好。
4. 客户端 Token 与 API 网关结合
这个方案意味着所有请求都通过网关，从而有效地隐藏了微服务。在请求时，网关将原始用户令牌转换为内部会话 ID 令牌。在这种情况下，注销就不是问题，因为网关可以在注销时撤销用户的令牌。

## 微服务常见安全认证方案
### Http 基本认证
HTTP Basic Authentication（HTTP 基本认证）是 HTTP 1.0 提出的一种认证机制。
HTTP 基本认证的过程如下：
- 客户端发送 HTTP Request 给服务器。
- 因为 Request 中没有包含 Authorization header，服务器会返回一个 401 Unauthozied 给客户端，并且在 Response 的 Header “WWW-Authenticate” 中添加信息。
- 客户端把用户名和密码用 BASE64 加密后，放在 Authorization Header 中发送给服务器， 认证成功。
- 服务器将 Authorization Header 中的用户名密码取出，进行验证， 如果验证通过，将根据请求，发送资源给客户端。
### 基于 Session 的认证
基于 Session 的认证应该是最常用的一种认证机制了。用户登录认证成功后，将用户相关数据存储到 Session 中，单体应用架构中，默认 Session 会存储在应用服务器中，并且将 Session ID 返回到客户端，存储在浏览器的 Cookie 中。
但是在分布式架构下，Session 存放于某个具体的应用服务器中自然就无法满足使用了，简单的可以通过 Session 复制或者 Session 粘制的方案来解决。
在微服务架构下，每个微服务拆分的粒度会很细，并且不只有用户和微服务打交道，更多还有微服务间的调用。这个时候上述两个方案都无法满足，就要求必须要将 Session 从应用服务器中剥离出来，存放在外部进行集中管理。可以是数据库，也可以是分布式缓存，如 Memchached、Redis 等。这正是 David Borsos 建议的第二种方案，**分布式 Session 方案**。

![image-20201022222925289](.\img\session分布式方案)

### 基于 Token 的认证
随着 Restful API、微服务的兴起，基于 Token 的认证现在已经越来越普遍。Token 和 Session ID 不同，并非只是一个 key。Token 一般会包含用户的相关信息，通过验证 Token 就可以完成身份校验。像 Twitter、微信、QQ、GitHub 等公有服务的 API 都是基于这种方式进行认证的，一些开发框架如 OpenStack、Kubernetes 内部 API 调用也是基于 Token 的认证。基于 Token 认证的一个典型流程如下：
- 用户输入登录信息（或者调用 Token 接口，传入用户信息），发送到身份认证服务进行认证（身份认证服务可以和服务端在一起，也可以分离，看微服务拆分情况了）。
- 身份验证服务验证登录信息是否正确，返回接口（一般接口中会包含用户基础信息、权限范围、有效时间等信息），客户端存储接口，可以存储在 Session 或者数据库中。
- 用户将 Token 放在 HTTP 请求头中，发起相关 API 调用。
- 被调用的微服务，验证 Token 权限。
- 服务端返回相关资源和数据。
基于 Token 认证的好处如下：
- 服务端无状态：Token 机制在服务端不需要存储 session 信息，因为 Token 自身包含了所有用户的相关信息。
- 性能较好，因为在验证 Token 时不用再去访问数据库或者远程服务进行权限校验，自然可以提升不少性能。
- 支持移动设备。
- 支持跨程序调用，Cookie 是不允许跨域访问的，而 Token 则不存在这个问题。
下面会重点介绍两种基于 Token 的认证方案 JWT/Oauth2.0。

## JWT 介绍

JSON Web Token（JWT）是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。来自 JWT RFC 7519 标准化的摘要说明：JSON Web Token 是一种紧凑的，URL 安全的方式，表示要在双方之间传输的声明。JWT 一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 Token 也可直接被用于认证，也可被加密。

**JWT 认证流程**

- 客户端调用登录接口（或者获取 token 接口），传入用户名密码。

- 服务端请求身份认证中心，确认用户名密码正确。

- 服务端创建 JWT，返回给客户端。

- 客户端拿到 JWT，进行存储（可以存储在缓存中，也可以存储在数据库中，如果是浏览器，可以存储在 Cookie 中）在后续请求中，在 HTTP 请求头中加上 JWT。

- 服务端校验 JWT，校验通过后，返回相关资源和数据。

### JWT 结构

JWT 是由三段信息构成的，第一段为头部（Header），第二段为载荷（Payload)，第三段为签名（Signature）。每一段内容都是一个 JSON 对象，将每一段 JSON 对象采用 BASE64 编码，将编码后的内容用**.**链接一起就构成了 JWT 字符串。如下：
header.payload.signature

#### 1. 头部（Header）

头部用于描述关于该 JWT 的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个 JSON 对象。

```json
{
"typ":"JWT",
"alg":"HS256"
}
```

上面代码中，`alg`属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；`typ`属性表示这个令牌（token）的类型（type），JWT 令牌统一写为`JWT`。

最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。

#### 2. 载荷（payload）

载荷就是存放有效信息的地方。有效信息包含三个部分：

- 标准中注册的声明
- 公共的声明
- 私有的声明

标准中注册的声明（建议但不强制使用）：

- iss：JWT 签发者
- sub：JWT 所面向的用户
- aud：接收 JWT 的一方
- exp：JWT 的过期时间，这个过期时间必须要大于签发时间
- nbf：定义在什么时间之前，该 JWT 都是不可用的
- iat：JWT 的签发时间
- jti：JWT 的唯一身份标识，主要用来作为一次性 token, 从而回避重放攻击。

公共的声明 ：
公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息. 但不建议添加敏感信息，因为该部分在客户端**可解密**。

私有的声明 ：
私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为**明文信息**。

私有声明例子。

```javascript
{
   "sub": "1234567890",
   "name": "John Doe",
   "admin": true
 }
```

示例如下：
```json
{
	"iss":"Obline JWT Builder",
	"iat":133859544,
	"exp":134896088,
	"aud":"www.liangtao.com"
	"sub":"liangtao@qq.com",
	"GivenName":"drgon",
	"Surname":"wang",
	"admin":true
}
```

#### 3. 签名（signature)

创建签名需要使用 Base64 编码后的 header 和 payload 以及一个秘钥。将 base64 加密后的 header 和 base64 加密后的 payload 使用. 连接组成的字符串，通过 header 中声明的加密方式进行加盐 secret 组合加密，然后就构成了 jwt 的第三部分。

比如：HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)

**JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。**

JWT 的优点：

- 跨语言，JSON 的格式保证了跨语言的支撑
- 基于 Token，无状态
- 占用字节小，便于传输

关于 Token 注销：
Token 的注销，由于 Token 不存储在服务端，由客户端存储，当用户注销时，Token 的有效时间还没有到，还是有效的。所以如何在用户注销登录时让 Token 注销是一个要关注的点。一般有如下几种方式：

- Token 存储在 Cookie 中，这样客户端注销时，自然可以清空掉。
- 注销时，将 Token 存放到分布式缓存中，每次校验 Token 时去检查下该 Token 是否已注销。不过这样也就失去了快速校验 Token 的优点。
- 多采用短期令牌，比如令牌有效期是 20 分钟，这样可以一定程度上降低注销后 Token 可用性的风险。

### Base64URL

前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。

JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符`+`、`/`和`=`，在 URL 里面有特殊含义，所以要被替换掉：`=`被省略、`+`替换成`-`，`/`替换成`_` 。这就是 Base64URL 算法。

### JWT 的使用方式

客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。

此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。

```javascript
Authorization: Bearer <token>
```
另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。

###  JWT 的几个特点

（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。

（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。

（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。

（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。

（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。

（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。


## OAuth 2.0 介绍

OAuth 的官网介绍：An open protocol to allow secure API authorization in a simple and standard method from desktop and web applications。OAuth 是一种开放的协议，为桌面程序或者基于 BS 的 web 应用提供了一种简单的，标准的方式去访问需要用户授权的 API 服务。OAUTH 认证授权具有以下特点：

- 简单：不管是 OAuth 服务提供者还是应用开发者，都很容易于理解与使用；
- 安全：没有涉及到用户密钥等信息，更安全更灵活；
- 开放：任何服务提供商都可以实现 OAuth，任何软件开发商都可以使用 OAuth;

OAuth 2.0 是 OAuth 协议的下一版本，但不向后兼容 OAuth 1.0，即完全废止了 OAuth 1.0。OAuth 2.0 关注客户端开发者的简易性。要么通过组织在资源拥有者和 HTTP 服务商之间的被批准的交互动作代表用户，要么允许第三方应用代表用户获得访问的权限。同时为 Web 应用，桌面应用和手机，和起居室设备提供专门的认证流程。2012 年 10 月，OAuth 2.0 协议正式发布为 RFC 6749。

很多网站登录时，允许使用第三方网站的身份来进行登录，这称为“第三方登录”。比如知乎和慕课网等，可以使用微信，QQ，或微博来进行登录。一个网站想接入第三方登录，需要用到oAuth这个协议。

### 协议流程

在详细介绍oAuth2协议流程之前，先来简单了解几个角色，方便后续的理解。

- Resource Owner，资源所有者，因为是请求用户的头像和昵称的一些信息，所以资源的所有者一般指用户自己。
- Client，客户端，如web网站，app等。
- Resource Server，资源服务器，托管受保护资源的服务器。
- Authorization Server，授权服务器，一般和资源服务器是同一家公司的应用，主要是用来处理授权，给客户端颁发令牌。
- User-agent，用户代理，一般为web浏览器，在手机上就是app。

了解了上面这些角色之后，来看下oAuth2.0的运行流程是怎么样的。

```
 +--------+                               +---------------+
 |        |--(A)- Authorization Request ->|   Resource    |
 |        |                               |     Owner     |
 |        |<-(B)-- Authorization Grant ---|               |
 |        |                               +---------------+
 |        |
 |        |                               +---------------+
 |        |--(C)-- Authorization Grant -->| Authorization |
 | Client |                               |     Server    |
 |        |<-(D)----- Access Token -------|               |
 |        |                               +---------------+
 |        |
 |        |                               +---------------+
 |        |--(E)----- Access Token ------>|    Resource   |
 |        |                               |     Server    |
 |        |<-(F)--- Protected Resource ---|               |
 +--------+                               +---------------+
```

(A). 用户打开客户端(Client)，客户端向授权服务器(Resource Owner)发送一个授权请求

(B). 用户同意给客户端(Client)授权

(C). 客户端使用刚才的授权去向认证服务器(Authorization Server)认证

(D). 认证服务器认证通过后，会给客户端发放令牌(Access Token)

(E). 客户端拿着令牌(Access Token)，去向资源服务器(Resource Server)申请获取资源

(F). 资源服务器确认令牌之后，给客户端返回受保护的资源(Protected Resource)

### 授权方式

在oAuth2当中，定义了四种授权方式，针对不同的业务场景：

- 授权码模式(authorization code)： 流程最完整和严密的一种授权方式，服务器和客户端配合使用，主要是针对web服务器的情况采用
- 简化模式(implicit)：主要用于移动应用程序或纯前端的web应用程序，主要是针对没有web服务器的情况采用
- 密码模式(resource owner password credentials)：不推荐，用户需要向客户端提供自己的账号和密码，如果客户端是自家应用的话，也是可以的
- 客户端模式(client credentials)：客户端以自己的名义，而不是用户的名义，向“服务提供商”进行认证，如微信公众号以此access_token来拉取所有已关注用户的信息，docker到dockerhub拉取镜像等

### 授权码模式

```
 +----------+
 | Resource |
 |   Owner  |
 |          |
 +----------+
      ^
      |
     (B)
 +----|-----+          Client Identifier      +---------------+
 |         -+----(A)-- & Redirection URI ---->|               |
 |  User-   |                                 | Authorization |
 |  Agent  -+----(B)-- User authenticates --->|     Server    |
 |          |                                 |               |
 |         -+----(C)-- Authorization Code ---<|               |
 +-|----|---+                                 +---------------+
   |    |                                         ^      v
  (A)  (C)                                        |      |
   |    |                                         |      |
   ^    v                                         |      |
 +---------+                                      |      |
 |         |>---(D)-- Authorization Code ---------'      |
 |  Client |          & Redirection URI                  |
 |         |                                             |
 |         |<---(E)----- Access Token -------------------'
 +---------+       (w/ Optional Refresh Token)
```

说明步骤（A），（B）和（C）的线在通过用户代理时分为两部分。

授权码模式如上图所示，这种流程是功能最完整，流程也是最严密的授权方式，适用于那些有后端的web应用。它的特点是通过客户端的后台服务器和服务商的认证服务器进行通讯。它的流程如下,如果我想使用github来接入第三方登录：

(A). 用户(Resource Owner)在用户代理(User-Agent，如web浏览器，app)上选择了第三方应用(如github)来进行登录，会重定向到github的授权端点：

```
  https://github.com/login/oauth/authorize?
   response_type=code&
   client_id=your_code&
   redirect_uri=重定向的url&
   scope=read&
   state=uuid
```

| 字段          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| response_type | 必须，在**授权码**模式中固定为code                           |
| client_id     | 必须，唯一标识了客户端，在github注册时获得的客户端ID         |
| redirect_url  | 客户端在github注册的重定向url，用户同意或拒绝的时候都会跳转到这个重定向url，一般是后端地址，实现前后端的验证分离，增加安全性 |
| scope         | 可选，请求资源范围，如有多项，使用多个空格隔开               |
| state         | 推荐，客户端生成的随机数，资源服务器会原样返回，防止CSRF的攻击 |

(B). 页面跳转后，github会要求用户登录，然后询问是否给予客户端授权，用户点击同意。

(C). 然后github就会将授权码(Authorization Code)返回给redirect_uri(重定向uri)。

```
redirect_uri?code=xxxxxxx&state=uuid
```

| 字段  | 描述               |
| ----- | ------------------ |
| code  | 必须，授权码       |
| state | 防止CSRF攻击的参数 |

(D). 客户端(Client)在通过在URL中取出授权码之后，就可以在后端向github请求令牌

```
  https://github.com/login/oauth/access_token?
  client_id=your_code&
  client_secret=your_secret&
  grant_type=authorization_code&
  code=取出的code&
  redirect_uri=重定向的url
复制代码
```

| 字段          | 描述                                  |
| ------------- | ------------------------------------- |
| client_id     | 必须，客户端在github注册的唯一标识    |
| client_secret | 必须，客户端在github注册时返回的密钥  |
| grant_type    | 必须，authorization_code/refresh_code |
| code          | 必须，上一步中取出的授权码            |
| redirect_uri  | 必须，完成授权之后的回调地址          |

(E). github给redirect_uri指定的地址返回AccessToken，通过JSON格式返回

```
{
  "access_token":"ACCESS_TOKEN",
  "token_type":"bearer",
  "expires_in":2592000,
  "refresh_token":"REFRESH_TOKEN",
  "scope":"read",
  "uid":100101,
  "info":{...}
}
```

客户端就可以在后端取到access_token,在这段json中，还返回了一个refresh_token，这个refresh_token表示用于访问下一次的更新令牌，refresh_token的时效性比access_token长，当access_token过期时，可以使用refresh_token换取新的access_token。

### 简化模式

简化模式主要针对没有后端的纯前端应用，在这种情况下，因为没有后端，所以就不能采用授权码模式的这种流程了，必须要把access_token存在前端。

```
 +----------+
 | Resource |
 |  Owner   |
 |          |
 +----------+
      ^
      |
     (B)
 +----|-----+          Client Identifier     +---------------+
 |         -+----(A)-- & Redirection URI --->|               |
 |  User-   |                                | Authorization |
 |  Agent  -|----(B)-- User authenticates -->|     Server    |
 |          |                                |               |
 |          |<---(C)--- Redirection URI ----<|               |
 |          |          with Access Token     +---------------+
 |          |            in Fragment
 |          |                                +---------------+
 |          |----(D)--- Redirection URI ---->|   Web-Hosted  |
 |          |          without Fragment      |     Client    |
 |          |                                |    Resource   |
 |     (F)  |<---(E)------- Script ---------<|               |
 |          |                                +---------------+
 +-|--------+
   |    |
  (A)  (G) Access Token
   |    |
   ^    v
 +---------+
 |         |
 |  Client |
 |         |
 +---------+
```

(A). 用户(Resource Owner)在用户代理(User-Agent,一些纯前端应用)上选择了第三方应用(如github)来进行登录，会重定向到github的授权端点：

```javascript
https://b.githubu/oauth/authorize?
  response_type=token&
  client_id=CLIENT_ID&
  redirect_uri=CALLBACK_URL&
  scope=read&
  state=uuid
```

| 字段          | 描述                                    |
| ------------- | --------------------------------------- |
| response_type | 必须，参数为token，表示要求直接返回令牌 |
| 其余同授权码  |                                         |

用户跳转到 github网站，登录后同意给予 User-Agent网站授权。这时，B 网站就会跳回`redirect_uri`参数指定的跳转网址，并且把令牌作为 URL 参数，传给 该网站。

主要是B这个步骤，页面跳转到github网站，用户同意给予客户端授权。github就会把令牌作为URL参数，跳转回到redirect_uri的这个回调地址。

```
https://a.com/callback#token=ACCESS_TOKEN
```

注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在"中间人攻击"的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。

这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。

### 密码模式

如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为"密码式"（password）。

```
+----------+
 | Resource |
 |  Owner   |
 |          |
 +----------+
      v
      |    Resource Owner
     (A) Password Credentials
      |
      v
 +---------+                                  +---------------+
 |         |>--(B)---- Resource Owner ------->|               |
 |         |         Password Credentials     | Authorization |
 | Client  |                                  |     Server    |
 |         |<--(C)---- Access Token ---------<|               |
 |         |    (w/ Optional Refresh Token)   |               |
 +---------+                                  +---------------+

        Figure 5: Resource Owner Password Credentials Flow
复制代码
```

密码模式就是用户向客户端提供自己的账号和密码，客户端使用这些信息去向我们的服务提供商去索要一个授权。

```javascript
https://oauth.b.com/token?
  grant_type=password&
  username=USERNAME&
  password=PASSWORD&
  client_id=CLIENT_ID
```

上面 URL 中，`grant_type`参数是授权方式，这里的`password`表示"密码式"，`username`和`password`是 B 的用户名和密码。网站验证身份通过后，直接给出令牌。注意，这时**不需要跳转**，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，Client因此拿到令牌。

### 客户端模式

客户端以自己的名义，而不是用户的名义，向“服务提供商”进行认证，如微信公众号以此access_token来拉取所有已关注用户的信息，docker到dockerhub拉取镜像等。

```
 +---------+                                  +---------------+
 |         |                                  |               |
 |         |>--(A)- Client Authentication --->| Authorization |
 | Client  |                                  |     Server    |
 |         |<--(B)---- Access Token ---------<|               |
 |         |                                  |               |
 +---------+                                  +---------------+

                 Figure 6: Client Credentials Flow
复制代码
```

```javascript
 https://oauth.b.com/token?
   grant_type=client_credentials&
   client_id=CLIENT_ID&
   client_secret=CLIENT_SECRET
```

上面 URL 中，`grant_type`参数等于`client_credentials`表示采用凭证式，`client_id`和`client_secret`用来让 Authorization Server确认 Client 的身份。

第二步，Client 网站验证通过以后，直接返回令牌。

这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌,不需要用户去参与。

### 令牌的更新

令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。

具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。

```javascript
 https://b.com/oauth/token?
   grant_type=refresh_token&
   client_id=CLIENT_ID&
   client_secret=CLIENT_SECRET&
   refresh_token=REFRESH_TOKEN
```

上面 URL 中，`grant_type`参数为`refresh_token`表示要求更新令牌，`client_id`参数和`client_secret`参数用于确认身份`，refresh_token`参数就是用于更新令牌的令牌。B 网站验证通过以后，就会颁发新的令牌。
