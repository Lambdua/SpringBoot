# 深入了解RabbitMQ工作原理及简单使用



## RabbitMQ简介

在介绍RabbitMQ之前实现要介绍一下MQ，MQ是什么？

MQ全称是Message Queue，可以理解为消息队列的意思，简单来说就是消息以管道的方式进行传递。

RabbitMQ是一个实现了AMQP（Advanced Message Queuing Protocol）高级消息队列协议的消息队列服务。

## 使用场景

在我们秒杀抢购商品的时候，系统会提醒我们稍等排队中，而不是像几年前一样页面卡死或报错给用户。

像这种排队结算就用到了消息队列机制，放入通道里面一个一个结算处理，而不是某个时间断突然涌入大批量的查询新增把数据库给搞宕机，所以RabbitMQ本质上起到的作用就是削峰填谷，为业务保驾护航。

## 为什么选择RabbitMQ

现在的市面上有很多MQ可以选择，比如ActiveMQ、ZeroMQ、Appche Qpid，那问题来了为什么要选择RabbitMQ？

1. 除了Qpid，RabbitMQ是唯一一个实现了AMQP标准的消息服务器；

2. 可靠性，RabbitMQ的持久化支持，保证了消息的稳定性；

3. 高并发，RabbitMQ使用了Erlang开发语言，Erlang是为电话交换机开发的语言，天生自带高并发光环，和高可用特性；

4. 集群部署简单，正是应为Erlang使得RabbitMQ集群部署变的超级简单；

5. 社区活跃度高，根据网上资料来看，RabbitMQ也是首选；

## 工作机制

   **生产者、消费者和代理**

   在了解消息通讯之前首先要了解3个概念：生产者、消费者和代理。

   生产者：消息的创建者，负责创建和推送数据到消息服务器；

   消费者：消息的接收方，用于处理数据和确认消息；

   代理：就是RabbitMQ本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。

   **消息发送原理**

   首先你必须连接到Rabbit才能发布和消费消息，那怎么连接和发送消息的呢？

   你的应用程序和Rabbit Server之间会创建一个TCP连接，一旦TCP打开，并通过了认证，认证就是你试图连接Rabbit之前发送的Rabbit服务器连接信息和用户名和密码，有点像程序连接数据库，使用Java有两种连接认证的方式，后面代码会详细介绍，一旦认证通过你的应用程序和Rabbit就创建了一条AMQP信道（Channel）。

   信道是创建在“真实”TCP上的虚拟连接，AMQP命令都是通过信道发送出去的，每个信道都会有一个唯一的ID，不论是发布消息，订阅队列或者介绍消息都是通过信道完成的。

**为什么不通过TCP直接发送命令？**

   对于操作系统来说创建和销毁TCP会话是非常昂贵的开销，假设高峰期每秒有成千上万条连接，每个连接都要创建一条TCP会话，这就造成了TCP连接的巨大浪费，而且操作系统每秒能创建的TCP也是有限的，因此很快就会遇到系统瓶颈。如果我们每个请求都使用一条TCP连接，既满足了性能的需要，又能确保每个连接的私密性，这就是引入信道概念的原因。

## 概念介绍

**ConnectionFactory（连接管理器）：**应用程序与Rabbit之间建立连接的管理器，程序代码中使用；

**Channel（信道）：**消息推送使用的通道；

**Exchange（交换器）：**用于接受、分配消息；

**Queue（队列）**：用于存储生产者的消息；

**RoutingKey（路由键）**：用于把生成者的数据分配到交换器上；

**BindingKey（绑定键）**：用于把交换器的消息绑定到队列上；

![preview](.\img\rabbitMq交互图.jpg)

消息转发流程：

![img](.\img\消息转发流程图)

## 消息持久化

Rabbit队列和交换器有一个不可告人的秘密，就是默认情况下重启服务器会导致消息丢失，那么怎么保证Rabbit在重启的时候不丢失呢？答案就是消息持久化。

当你把消息发送到Rabbit服务器的时候，你需要选择你是否要进行持久化，但这并不能保证Rabbit能从崩溃中恢复，想要Rabbit消息能恢复必须满足3个条件：

1. 投递消息的时候durable设置为true
2. 设置投递模式deliveryMode设置为2（持久），代码：channel.basicPublish(x, x, MessageProperties.PERSISTENT_TEXT_PLAIN,x)，参数3设置为存储纯文本到磁盘；
3. 消息已经到达持久化交换器上；
4. 消息已经到达持久化的队列；

### Spring AMQP消息持久化的实现方式

Spring AMQP 是对原生的 RabbitMQ 客户端的封装。一般情况下，我们只需要定义交换器的持久化和队列的持久化。

其中，交换器的持久化配置如下。

```
// 参数1 name ：交互器名
// 参数2 durable ：是否持久化
// 参数3 autoDelete ：当所有消费客户端连接断开后，是否自动删除队列
new TopicExchange(name, durable, autoDelete)
```

此外，还需要再配置队列的持久化。

```
// 参数1 name ：队列名
// 参数2 durable ：是否持久化
// 参数3 exclusive ：仅创建者可以使用的私有队列，断开后自动删除
// 参数4 autoDelete : 当所有消费客户端连接断开后，是否自动删除队列
new Queue(name, durable, exclusive, autoDelete);
```

至此，RabbitMQ 的消息持久化配置完毕。那么，消息的持久化难道不需要配置么？确实如此，spring amqp 默认是对消息进行持久化的。

### 持久化工作原理

Rabbit会将你的持久化消息写入磁盘上的持久化日志文件，等消息被消费之后，Rabbit会把这条消息标识为等待垃圾回收。

### 持久化的缺点

消息持久化的优点显而易见，但缺点也很明显，那就是性能，因为要写入硬盘要比写入内存性能较低很多，从而降低了服务器的吞吐量，尽管使用SSD硬盘可以使事情得到缓解，但他仍然吸干了Rabbit的性能，当消息成千上万条要写入磁盘的时候，性能是很低的。

## 消息模型代码示例

### 订阅模型-Fanout（广播模式）

在这种订阅模式中，生产者发布消息，所有消费者都可以获取所有消息。

#### 示例图

![img](.\img\广播模式图)

P：生产者，如寄快递

X: 交换机，相当于快递公司

红色区域：队列，如快递区，等待消费者拿快递

C1、C2：消费者，如收快递

代码实现 见 fanout包及 com.lt.mq.config.FanoutRabbitConfig

### 订阅模型-Direct（路由模式）

在这种订阅模式中，生产者发布消息，消费者有选择性的接收消息。队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）。消息的发送方在向Exchange发送消息时，也必须指定消息的routing key

#### 示例图

![img](.\img\Direct路由模式图) P：生产者，如寄快递

X: 交换机，相当于快递公司

红色区域：队列，如快递区，等待消费者拿快递

C1、C2：消费者，如收快递

error、info这些就是我们讲的RoutingKey

代码实现 见代码

### 订阅模型-Topic（通配符模式）

#### 示例图

![img](.\img\topic通配符模式)

`Topic`类型的`Exchange`与`Direct`相比，都是可以根据`RoutingKey`把消息路由到不同的队列。只不过`Topic`类型`Exchange`可以让队列在绑定`Routing key` 的时候使用**通配符**！

`Routingkey` 一般都是有一个或多个单词组成，多个单词之间以”.”分割

**通配符规则：**

​         `#`：匹配一个或多个词

​         `*`：匹配不多不少恰好1个词